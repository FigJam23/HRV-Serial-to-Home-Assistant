esphome:
  name: hrv_keypad
  friendly_name: HRV Keypad Emulator

esp8266:
  board: d1_mini

wifi:
  ssid: "Reaver"
  password: "FigjamDilligaf74"
  manual_ip:
    static_ip: 192.168.1.100
    gateway:   192.168.1.1
    subnet:    255.255.255.0
  power_save_mode: none
  fast_connect: true

logger:
  baud_rate: 115200
  level: DEBUG

api:
  encryption:
    key: "hZXm4NPWC33G3NS3kzqXkXR5mHUn/PUIUY+8RTcm4Ps="

ota:
  platform: esphome
  password: "283355a588a90db0f31782330ad9f820"

web_server:
  port: 80

uart:
  id: bus
  tx_pin: D1
  rx_pin: D2
  baud_rate: 1200
  data_bits: 8
  parity: NONE
  stop_bits: 1
  debug:
    direction: BOTH

# ───────────────────────────────────────────────────────────────────────────────
# Diagnostics
# ───────────────────────────────────────────────────────────────────────────────
text_sensor:
  - platform: template
    id: last_tx
    name: "Last TX Frame"
  - platform: template
    id: last_rx
    name: "Last RX Frame"

# ───────────────────────────────────────────────────────────────────────────────
# Internal state
# ───────────────────────────────────────────────────────────────────────────────
globals:
  - id: target_percent
    type: int
    restore_value: no
    initial_value: '0'
  - id: hold_on
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: last_sent_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: last_ack_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: keepalive_period_ms
    type: int
    restore_value: no
    initial_value: '900'        # resend cadence (~0.9s)
  - id: rx_seen
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: rx_b0
    type: int
    restore_value: no
    initial_value: '0'
  - id: rx_b1
    type: int
    restore_value: no
    initial_value: '0'

# ───────────────────────────────────────────────────────────────────────────────
# RX assembler & ACK tracking
# ───────────────────────────────────────────────────────────────────────────────
script:
  - id: process_rx
    mode: single
    then:
      - lambda: |-
          static std::vector<uint8_t> buf;
          auto u = id(bus);
          while (u->available()) {
            uint8_t b; u->read_byte(&b);
            if (buf.empty()) { if (b==0x7E) buf.push_back(b); continue; }
            buf.push_back(b);
            if (b==0x7E && buf.size() >= 5) {
              // verify checksum
              size_t ci = buf.size() - 2;
              int sum = 0;
              for (size_t i=1;i<ci;i++) sum -= buf[i];
              bool ok = ((uint8_t)(sum & 0xFF)) == buf[ci];

              std::string s; char tmp[4];
              for (auto x: buf) { sprintf(tmp, "%02X ", x); s += tmp; }
              id(last_rx).publish_state(s);

              if (ok) {
                id(rx_b0) = buf.size()>1 ? buf[1] : 0;
                id(rx_b1) = buf.size()>2 ? buf[2] : 0;
                id(rx_seen) = true;
                if (id(rx_b0) == 0x30 && id(rx_b1) == 0x01) {
                  id(last_ack_ms) = millis();
                }
              }
              buf.clear();
            }
            if (buf.size() > 64) buf.clear();
          }

  # Send current target_percent as a fan command (31 01 XX PP 1E 84 F0)
  - id: send_fan_current
    mode: queued
    then:
      - lambda: |-
          int p = id(target_percent);
          if (p < 0) p = 0;
          if (p > 100) p = 100;

          // Heuristic from captures: 0x4E (≤30), 0x4F (31..75), 0x50 (≥76)
          uint8_t code = (p <= 30) ? 0x4E : (p <= 75 ? 0x4F : 0x50);

          std::vector<uint8_t> body{0x31,0x01,code,(uint8_t)p,0x1E,0x84,0xF0};
          std::vector<uint8_t> f{0x7E};
          f.insert(f.end(), body.begin(), body.end());
          int sum=0; for (size_t i=1;i<f.size(); ++i) sum -= f[i];
          f.push_back((uint8_t)sum); f.push_back(0x7E);

          auto u = id(bus);
          std::string s; char buf[4];
          for (auto v: f) { sprintf(buf, "%02X ", v); s += buf; u->write_byte(v); }
          id(last_tx).publish_state(s);
          id(last_sent_ms) = millis();

  # Minimal re-handshake (gated by wait-any)
  - id: rehandshake
    mode: restart
    then:
      - lambda: |-
          auto send = [&](std::initializer_list<uint8_t> body){
            auto u = id(bus);
            std::vector<uint8_t> f{0x7E};
            f.insert(f.end(), body.begin(), body.end());
            int sum=0; for(size_t i=1;i<f.size(); ++i) sum -= f[i];
            f.push_back((uint8_t)sum); f.push_back(0x7E);
            std::string s; char tmp[4];
            for (auto v: f){ sprintf(tmp,"%02X ",v); s+=tmp; u->write_byte(v); }
            id(last_tx).publish_state(s);
          };
          auto wait_any = [&](uint32_t ms_timeout)->bool{
            id(rx_seen) = false;
            uint32_t t0 = millis();
            while (!id(rx_seen) && (millis()-t0 < ms_timeout)) { delay(1); yield(); }
            return id(rx_seen);
          };

          for (int i=0;i<4;i++){ send({0x36,0x00,0x00,0x00}); wait_any(250); }
          for (int i=0;i<4;i++){ send({0x38,0x00,0x00,0x00}); wait_any(250); }
          for (int i=0;i<4;i++){ send({0x46,0x00,0x00,0x00}); wait_any(250); }

# Poll UART frequently
interval:
  - interval: 10ms
    then:
      - script.execute: process_rx

# Keepalive loop + watchdog
  - interval: 200ms
    then:
      - lambda: |-
          // Periodic resend to keep controller happy
          if (id(hold_on)) {
            if (millis() - id(last_sent_ms) > (uint32_t) id(keepalive_period_ms)) {
              id(send_fan_current).execute();
            }
            // If no 0x30 01 ACK in >3s, rehandshake and resend once
            uint32_t now = millis();
            if (id(last_ack_ms) == 0 || (now - id(last_ack_ms)) > 3000) {
              ESP_LOGW("KP_WD","No 0x30 01 ACK >3s; re-handshake");
              id(rehandshake).execute();
              id(send_fan_current).execute();
              id(last_ack_ms) = now;  // prevent thrash
            }
          }

# ───────────────────────────────────────────────────────────────────────────────
# Controls
# ───────────────────────────────────────────────────────────────────────────────
number:
  - platform: template
    name: "HRV Fan %"
    id: fan_percent
    min_value: 0
    max_value: 100
    step: 1
    optimistic: true
    restore_value: false
    on_value:
      - lambda: |-
          id(target_percent) = (int)x;
          id(hold_on) = true;           // start keepalive automatically
          id(send_fan_current).execute();

button:
  # Quick presets
  - platform: template
    name: "Fan 0%"
    on_press:
      - lambda: |-
          id(target_percent)=0; id(hold_on)=true; id(send_fan_current).execute();

  - platform: template
    name: "Fan 25%"
    on_press:
      - lambda: |-
          id(target_percent)=25; id(hold_on)=true; id(send_fan_current).execute();

  - platform: template
    name: "Fan 50%"
    on_press:
      - lambda: |-
          id(target_percent)=50; id(hold_on)=true; id(send_fan_current).execute();

  - platform: template
    name: "Fan 75%"
    on_press:
      - lambda: |-
          id(target_percent)=75; id(hold_on)=true; id(send_fan_current).execute();

  - platform: template
    name: "Fan 100%"
    on_press:
      - lambda: |-
          id(target_percent)=100; id(hold_on)=true; id(send_fan_current).execute();

  # Nudges
  - platform: template
    name: "Fan +1%"
    on_press:
      - lambda: |-
          id(target_percent) = std::min(100, id(target_percent)+1);
          id(hold_on)=true; id(send_fan_current).execute();

  - platform: template
    name: "Fan -1%"
    on_press:
      - lambda: |-
          id(target_percent) = std::max(0, id(target_percent)-1);
          id(hold_on)=true; id(send_fan_current).execute();

  - platform: template
    name: "Fan +5%"
    on_press:
      - lambda: |-
          id(target_percent) = std::min(100, id(target_percent)+5);
          id(hold_on)=true; id(send_fan_current).execute();

  - platform: template
    name: "Fan -5%"
    on_press:
      - lambda: |-
          id(target_percent) = std::max(0, id(target_percent)-5);
          id(hold_on)=true; id(send_fan_current).execute();

  # Keepalive control
  - platform: template
    name: "Keepalive START"
    on_press:
      - lambda: |-
          id(hold_on)=true; id(send_fan_current).execute();

  - platform: template
    name: "Keepalive STOP"
    on_press:
      - lambda: |-
          id(hold_on)=false;

  # Manual re-handshake if needed
  - platform: template
    name: "Re-Handshake"
    on_press:
      - script.execute: rehandshake
