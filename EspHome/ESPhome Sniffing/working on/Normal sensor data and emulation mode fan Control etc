esphome:
  name: hrv
  friendly_name: HRV

esp8266:
  board: d1_mini

wifi:
  ssid: "Reaver"
  password: "FigjamDilligaf74"
  manual_ip:
    static_ip: 192.168.1.100
    gateway: 192.168.1.1
    subnet: 255.255.255.0
  power_save_mode: none
  fast_connect: true
  reboot_timeout: 5min
  ap:
    ssid: "Hrv Fallback Hotspot"
    password: "Justj33p"

logger:
  baud_rate: 115200
  level: DEBUG

api:
  encryption:
    key: "hZXm4NPWC33G3NS3kzqXkXR5mHUn/PUIUY+8RTcm4Ps="

ota:
  platform: esphome
  password: "283355a588a90db0f31782330ad9f820"

web_server:
  port: 80

mqtt:
  id: hrv_mqtt
  broker: 192.168.1.44
  username: mqtt
  password: Justj33p
  discovery: true
  topic_prefix: "hassio/hrv"
  keepalive: 60s
  on_connect:
    - lambda: |-
        ESP_LOGD("MQTT","Connected");
        id(last_house_temp)=255;
        id(last_roof_temp)=255;
        id(last_setpoint)=255;
        id(last_fan_speed)=255;
  on_disconnect:
    - lambda: |-
        ESP_LOGD("MQTT","Disconnected");

output:
  - platform: gpio
    pin: GPIO2
    id: led
    inverted: true

uart:
  id: hrv_uart
  rx_pin: D2
  tx_pin: D1
  baud_rate: 1200

# ───────── Globals ─────────
globals:
  # Last decoded real values
  - id: last_house_temp
    type: float
    initial_value: "255"
  - id: last_roof_temp
    type: float
    initial_value: "255"
  - id: last_fan_speed
    type: int
    initial_value: "255"
  - id: last_setpoint
    type: int
    initial_value: "255"
  - id: last_fan_mode
    type: std::string
    initial_value: "\"\""
  - id: last_activity
    type: uint32_t
    initial_value: "0"

  # Time each sensor last updated (millis)
  - id: ts_house
    type: uint32_t
    initial_value: "0"
  - id: ts_roof
    type: uint32_t
    initial_value: "0"
  - id: ts_fan
    type: uint32_t
    initial_value: "0"
  - id: ts_setpoint
    type: uint32_t
    initial_value: "0"

  # Emulation mode / state machine
  - id: emulation_active
    type: bool
    initial_value: "false"
  - id: emulate_phase
    type: uint8_t
    initial_value: "0"        # 0 idle, 1 boot burst, 2 periodic
  - id: emulate_index
    type: int
    initial_value: "0"
  - id: last_emulate_ms
    type: uint32_t
    initial_value: "0"

  # Desired outputs while emulating
  - id: desired_fan_speed
    type: int
    initial_value: "10"        # start 10%
  - id: desired_setpoint
    type: int
    initial_value: "30"
  - id: emulate_temp_c
    type: float
    initial_value: "22.5"

  # Remember last emulated sent values to avoid spamming identical frames
  - id: last_emul_sent_fan
    type: int
    initial_value: "-1"
  - id: last_emul_sent_setp
    type: int
    initial_value: "-1"
  - id: last_emul_sent_temp
    type: float
    initial_value: "-1000"

  # Sensor timeout ms (after which we zero values in normal mode)
  - id: sensor_timeout_ms
    type: uint32_t
    initial_value: "15000"

# ───────── Sensors (template) ─────────
sensor:
  - platform: template
    name: "HRV House Temp"
    id: hrv_house_temp
    unit_of_measurement: "°C"
    accuracy_decimals: 1
  - platform: template
    name: "HRV Roof Temp"
    id: hrv_roof_temp
    unit_of_measurement: "°C"
    accuracy_decimals: 1
  - platform: template
    name: "HRV Control Setpoint"
    id: hrv_setpoint
    unit_of_measurement: "°C"
    accuracy_decimals: 0
  - platform: template
    name: "HRV Fan Speed"
    id: hrv_fan_speed
    unit_of_measurement: "%"
    icon: "mdi:fan"
    accuracy_decimals: 0
  - platform: template
    name: "HRV Humidity"
    id: hrv_humidity
    unit_of_measurement: "%"
    accuracy_decimals: 1
  - platform: wifi_signal
    name: "HRV WiFi Signal"
    id: hrv_wifi_signal
    update_interval: 30s

# Optional number to adjust setpoint while emulating
number:
  - platform: template
    name: "HRV Emu Setpoint"
    id: hrv_emu_setpoint
    optimistic: true
    min_value: 10
    max_value: 40
    step: 1
    unit_of_measurement: "°C"
    set_action:
      - lambda: |-
          id(desired_setpoint) = int(x);
          ESP_LOGI("hrv_emul","Desired setpoint -> %d", id(desired_setpoint));

text_sensor:
  - platform: template
    name: "HRV Fan Mode"
    id: hrv_fan_mode
  - platform: template
    name: "HRV Raw Frame"
    id: hrv_raw_frame

# ───────── Emulation / Fan Speed Switches ─────────
switch:
  - platform: template
    name: "HRV Emulation Mode"
    id: hrv_emulation_switch
    optimistic: true
    restore_mode: DISABLED
    turn_on_action:
      - lambda: |-
          if(!id(emulation_active)){
            ESP_LOGI("hrv_emul","Enabling emulation");
            id(emulation_active)=true;
            id(emulate_phase)=1;
            id(emulate_index)=0;
            id(last_emulate_ms)=millis();
            // Seed sensors immediately
            id(hrv_house_temp).publish_state(id(emulate_temp_c));
            id(hrv_setpoint).publish_state(id(desired_setpoint));
            id(hrv_fan_speed).publish_state(id(desired_fan_speed));
            id(hrv_fan_mode).publish_state((id(desired_fan_speed)==0)?"Off": (std::to_string(id(desired_fan_speed)) + "%").c_str());
          }
    turn_off_action:
      - lambda: |-
          if(id(emulation_active)){
            ESP_LOGI("hrv_emul","Disabling emulation (return to live sniff)");
            id(emulation_active)=false;
            id(emulate_phase)=0;
          }

  - platform: template
    name: "HRV Fan 10%"
    id: fan_10
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(desired_fan_speed)=10;
          ESP_LOGI("hrv_emul","Fan target 10%%");
  - platform: template
    name: "HRV Fan 30%"
    id: fan_30
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(desired_fan_speed)=30;
          ESP_LOGI("hrv_emul","Fan target 30%%");
  - platform: template
    name: "HRV Fan 50%"
    id: fan_50
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(desired_fan_speed)=50;
          ESP_LOGI("hrv_emul","Fan target 50%%");
  - platform: template
    name: "HRV Fan 75%"
    id: fan_75
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(desired_fan_speed)=75;
          ESP_LOGI("hrv_emul","Fan target 75%%");
  - platform: template
    name: "HRV Fan 100%"
    id: fan_100
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(desired_fan_speed)=100;
          ESP_LOGI("hrv_emul","Fan target 100%%");

# ───────── Helper Scripts ─────────
script:
  # Send arbitrary hex string
  - id: send_hex_string
    parameters:
      hex: string
    then:
      - lambda: |-
          std::string s = hex;
          std::string comp;
          for(char c: s) if(!isspace((unsigned char)c)) comp+=c;
          if(comp.size()%2){ ESP_LOGW("hrv_send","Odd hex (%s)", comp.c_str()); return; }
          for(size_t i=0;i<comp.size(); i+=2){
            uint8_t v = strtol(comp.substr(i,2).c_str(), nullptr, 16);
            id(hrv_uart).write_byte(v);
            delay(7);
          }

  # Construct and send a dynamic "house status" frame when emulating
  - id: send_house_status_frame
    then:
      - lambda: |-
          // House frame format we inferred: 7E 31 01 TT TT FAN SETP 1E 84 70 CC 7E (example pattern)
          // We will mimic similar length to real frames: 7E 31 01 <tempHi> <tempLo> <fan> <setp> 1E 84 70 <cksum> 7E
          // temp raw = °C / 0.0625  (we round to nearest whole raw)
          float t = id(emulate_temp_c);
          // fallback to last real if plausible
            if(id(last_house_temp) < 200 && !isnan(id(last_house_temp))) t = id(last_house_temp);
          uint16_t rawT = (uint16_t)(t / 0.0625f + 0.5f);
          uint8_t th = (rawT >> 8) & 0xFF;
          uint8_t tl = rawT & 0xFF;
          uint8_t fan = (uint8_t) std::max(0,std::min(100,id(desired_fan_speed)));
          uint8_t setp = (uint8_t) std::max(0,std::min(100,id(desired_setpoint)));
          // constant trailer bytes we kept seeing: 1E 84 70
          uint8_t const1=0x1E, const2=0x84, const3=0x70;

          uint8_t frame[11];
          frame[0]=0x7E;
          frame[1]=0x31;
          frame[2]=0x01;
          frame[3]=th;
          frame[4]=tl;
          frame[5]=fan;
          frame[6]=setp;
          frame[7]=const1;
          frame[8]=const2;
          frame[9]=const3;

          // Checksum rule we used earlier: negative sum of bytes 1..(n-2)
          int sum=0;
          for(int i=1;i<=9;i++) sum -= frame[i];
          uint8_t cks = (uint8_t)(sum & 0xFF);
          frame[10]=cks;

          // Send
          for(int i=0;i<11;i++){
            id(hrv_uart).write_byte(frame[i]);
            delay(2);
          }
          // End marker second 7E? (Original frames already start & end with 7E; here we built one with single 7E at start.
          // Real frames: start 7E ... data ... checksum ... 7E end. Add end marker separately.
          id(hrv_uart).write_byte(0x7E);

          // Publish sensors directly (so even if we ignore our own frame parse we get updates)
          id(hrv_house_temp).publish_state(t);
          id(hrv_fan_speed).publish_state(fan);
          id(hrv_setpoint).publish_state(setp);
          std::string mode = (fan==0)?"Off":(fan==5)?"Idle":(fan==100)?"Full":(std::to_string(fan)+"%");
          id(hrv_fan_mode).publish_state(mode.c_str());

          // MQTT manual publish to keep HA in sync promptly
          id(hrv_mqtt).publish("housetemp", String(t).c_str());
          id(hrv_mqtt).publish("controltemp", String(setp).c_str());
          id(hrv_mqtt).publish("fanspeed", mode.c_str());

  # Emulation tick (boot sequence + periodic dynamic)
  - id: emulate_tick
    then:
      - lambda: |-
          if(!id(emulation_active)) return;
          uint32_t now = millis();

          static const char* BOOT_FRAMES[] = {
            "7E 37 01 6C 00 1E 84 BA 7E","7E 37 01 6C 00 1E 84 BA 7E",
            "7E 41 E3 DC 7E","7E 41 E3 DC 7E","7E 41 E3 DC 7E","7E 41 E3 DC 7E",
            "7E 38 00 00 00 C8 7E","7E 38 00 00 00 C8 7E","7E 38 00 00 00 C8 7E","7E 38 00 00 00 C8 7E",
            "7E 42 C3 FB 7E","7E 42 C3 FB 7E","7E 42 C3 FB 7E","7E 42 C3 FB 7E",
            "7E 46 00 00 00 BA 7E","7E 46 00 00 00 BA 7E","7E 46 00 00 00 BA 7E","7E 46 00 00 00 BA 7E",
            "7E 34 E3 E9 7E","7E 34 E3 E9 7E","7E 34 E3 E9 7E",
            "7E 33 C3 0A 7E","7E 33 C3 0A 7E","7E 33 C3 0A 7E","7E 33 C3 0A 7E",
            "7E 43 C3 FA 7E","7E 43 C3 FA 7E","7E 43 C3 FA 7E","7E 43 C3 FA 7E",
            "7E 35 83 48 7E","7E 35 83 48 7E","7E 35 83 48 7E","7E 35 83 48 7E"
          };
          const int BOOT_LEN = sizeof(BOOT_FRAMES)/sizeof(BOOT_FRAMES[0]);

          if(id(emulate_phase)==1){
            if(id(emulate_index) < BOOT_LEN){
              if(now - id(last_emulate_ms) > 120){
                id(last_emulate_ms)=now;
                id(send_hex_string).execute(std::string(BOOT_FRAMES[id(emulate_index)]));
                id(emulate_index)++;
              }
            } else {
              ESP_LOGI("hrv_emul","Boot frames done");
              id(emulate_phase)=2;
              id(last_emulate_ms)=now;
            }
            return;
          }

          if(id(emulate_phase)==2){
            // At least every 1000 ms; earlier if changes
            bool timer_elapsed = (now - id(last_emulate_ms)) > 1000;
            int fan = id(desired_fan_speed);
            int setp = id(desired_setpoint);
            float temp = (id(last_house_temp)<200)?id(last_house_temp):id(emulate_temp_c);

            bool changed = (fan != id(last_emul_sent_fan)) ||
                           (setp != id(last_emul_sent_setp)) ||
                           (fabsf(temp - id(last_emul_sent_temp)) >= 0.5f);

            // Force send at least every 10s even if no change
            bool force_refresh = (now - id(last_emulate_ms)) > 10000;

            if(timer_elapsed && (changed || force_refresh)){
              id(last_emulate_ms)=now;
              id(send_house_status_frame).execute();
              id(last_emul_sent_fan)=fan;
              id(last_emul_sent_setp)=setp;
              id(last_emul_sent_temp)=temp;
            }
          }

  # UART frame processor (ignored in emulation mode unless you want to watch bus)
  - id: hrv_process_uart
    then:
      - lambda: |-
          if(id(emulation_active)){
            // In emulation we ignore external frames (prevents overwriting simulated state)
            while(id(hrv_uart).available()){
              uint8_t dump; id(hrv_uart).read_byte(&dump);
            }
            return;
          }

          static std::vector<uint8_t> frame;
          auto publish_fan_mode = [&](int raw){
            std::string mode;
            if(raw==0) mode="Off";
            else if(raw==5) mode="Idle";
            else if(raw==100) mode="Full";
            else mode = std::to_string(raw)+"%";
            id(hrv_fan_mode).publish_state(mode.c_str());
          };

          while(id(hrv_uart).available()){
            uint8_t b=0; id(hrv_uart).read_byte(&b);
            id(last_activity)=millis();
            if(frame.empty()){
              if(b==0x7E) frame.push_back(b);
              continue;
            }
            frame.push_back(b);

            if(b==0x7E && frame.size()>=5){
              // Build hex output
              std::string hex; char h[4];
              for(auto v: frame){ snprintf(h,sizeof(h),"%02X ",v); hex += h; }
              if(!hex.empty()) hex.pop_back();
              id(hrv_raw_frame).publish_state(hex.c_str());

              if(frame.size()<=16 && frame.size()>=6){
                size_t cks_idx = frame.size()-2;
                if(cks_idx>1){
                  int sum=0;
                  for(size_t i=1;i<cks_idx;i++) sum -= frame[i];
                  uint8_t calc = uint8_t(sum & 0xFF);
                  uint8_t expect = frame[cks_idx];
                  if(calc==expect){
                    uint8_t type = frame[1];
                    if(type==0x31){ // house frame
                      if(frame.size()>=8){
                        uint16_t rawT = (uint16_t(frame[2])<<8)|frame[3];
                        float temp = rawT*0.0625f;
                        int t2 = int(temp*2+0.5f); temp = t2/2.0f;
                        if(temp < 200){
                          id(last_house_temp)=temp;
                          id(ts_house)=millis();
                          id(hrv_house_temp).publish_state(temp);
                        }
                        uint8_t fan=frame[5];
                        uint8_t setp=frame[6];
                        if(fan != id(last_fan_speed)){
                          id(last_fan_speed)=fan;
                          id(ts_fan)=millis();
                          id(hrv_fan_speed).publish_state(fan);
                          publish_fan_mode(fan);
                        }
                        if(setp != id(last_setpoint)){
                          id(last_setpoint)=setp;
                          id(ts_setpoint)=millis();
                          id(hrv_setpoint).publish_state(setp);
                        }
                      }
                    } else if(type==0x30){ // roof frame (shorter)
                      if(frame.size()>=7){
                        // From your data pattern: 7E 30 00 XX 00 YY 7E  (some variations)
                        // Interpret bytes 2/3 maybe raw temp? We'll decode similar to earlier: bytes 2&3 -> temp
                        uint16_t rawT = (uint16_t(frame[2])<<8)|frame[3];
                        // Some frames show high nibble small; guard unrealistic
                        if(rawT != 0){
                          float temp = rawT*0.0625f;
                          if(temp < 200){
                            int t2=int(temp*2+0.5f); temp=t2/2.0f;
                            id(last_roof_temp)=temp;
                            id(ts_roof)=millis();
                            id(hrv_roof_temp).publish_state(temp);
                          }
                        }
                      }
                    }
                  }
                }
              }
              frame.clear();
              continue;
            }

            if(frame.size()>24) frame.clear();
          }

  # Zero stale sensors in normal mode
  - id: zero_stale_check
    then:
      - lambda: |-
          if(id(emulation_active)) return;
          uint32_t now = millis();
          uint32_t to = id(sensor_timeout_ms);

          if(id(last_house_temp)!=255 && (now - id(ts_house) > to)){
            ESP_LOGW("hrv","House temp stale -> zero");
            id(last_house_temp)=0;
            id(hrv_house_temp).publish_state(0);
          }
          if(id(last_roof_temp)!=255 && (now - id(ts_roof) > to)){
            ESP_LOGW("hrv","Roof temp stale -> zero");
            id(last_roof_temp)=0;
            id(hrv_roof_temp).publish_state(0);
          }
            if(id(last_fan_speed)!=255 && (now - id(ts_fan) > to)){
            ESP_LOGW("hrv","Fan speed stale -> zero");
            id(last_fan_speed)=0;
            id(hrv_fan_speed).publish_state(0);
            id(hrv_fan_mode).publish_state("Off");
          }
          if(id(last_setpoint)!=255 && (now - id(ts_setpoint) > to)){
            ESP_LOGW("hrv","Setpoint stale -> zero");
            id(last_setpoint)=0;
            id(hrv_setpoint).publish_state(0);
          }

# ───────── Intervals ─────────
interval:
  - interval: 80ms
    then:
      - script.execute: hrv_process_uart

  - interval: 1s
    then:
      - script.execute: emulate_tick

  - interval: 5s
    then:
      - script.execute: zero_stale_check

  - interval: 30s
    then:
      - lambda: |-
          id(hrv_mqtt).publish("status","1");

  - interval: 10s
    then:
      - lambda: |-
          if(!id(emulation_active) && (millis() - id(last_activity) > 300000)){
            ESP_LOGW("WATCHDOG","No UART activity 5 min -> reboot");
            App.reboot();
          }
