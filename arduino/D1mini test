HRV Keypad (ESP8266 D1 mini) — No LVGL/SD

Features: Web UI + OTA, WiFi STA/AP fallback, mDNS, MQTT+HA discovery,

SHT31 on I2C, HRV UART (SoftwareSerial) @ 1200, Auto control,

Filter life with daily decrement, Sensor overrides.


***********************/
#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <ESP8266mDNS.h>
#include <ESP8266WebServer.h>
#include <PubSubClient.h>
#include <time.h>
#include <SoftwareSerial.h>
#include <LittleFS.h>
#include <FS.h>
#include <Wire.h>
#include <Adafruit_SHT31.h>
#include <Update.h>

// ===== USER DEFAULTS (first boot; then persisted in LittleFS) =====
static const char* WIFI_SSID_DEF     = "Reaver";
static const char* WIFI_PASSWORD_DEF = "FigjamDilligaf74";

static const char* AP_SSID = "HRV-Keypad";
static const char* AP_PASS = "12345678";

static const char* MQTT_HOST_DEF = "192.168.1.44";
static const uint16_t MQTT_PORT_DEF = 1883;
static const char* MQTT_USER_DEF = "mqtt";
static const char* MQTT_PASS_DEF = "Justj33p";

// NZ time (DST handled)
static const char* TZSTR = "NZST-12NZDT,M9.5.0/2,M4.1.0/3";
static const char* NTP1 = "pool.ntp.org";
static const char* NTP2 = "time.nist.gov";
static const char* NTP3 = "time.google.com";

// ===== Pins =====
// HRV half-duplex bus (SoftwareSerial): RX=D1(GPIO5), TX=D2(GPIO4)
static const int HRV_RX_PIN = D1;    // GPIO5
static const int HRV_TX_PIN = D2;    // GPIO4
SoftwareSerial HRV(HRV_RX_PIN, HRV_TX_PIN);  // RX, TX

// SHT31 I2C on D6 (SDA=GPIO12) and D5 (SCL=GPIO14)
static const int PIN_I2C_SDA = D6;  // GPIO12
static const int PIN_I2C_SCL = D5;  // GPIO14
Adafruit_SHT31 sht31 = Adafruit_SHT31();
static bool sht_ok = false;

// ===== MQTT topics (same as ESP32 version) =====
static const char* T_FILTER_DAYS     = "hassio/touchscreen_hrv/filter_days_remaining/state";
static const char* C_FILTER_DAYS_SET = "hassio/touchscreen_hrv/filter_days_remaining/set";
static const char* T_FILTER_LIFE     = "hassio/touchscreen_hrv/filter_life/state";
static const char* T_FAN_PERCENT     = "hassio/touchscreen_hrv/fan_percent/state";
static const char* T_FAN_CMD         = "hassio/touchscreen_hrv/fan_percent/set";
static const char* T_BOOST_ACTIVE    = "hassio/touchscreen_hrv/boost_active/state";
static const char* T_FILTER_NEEDED   = "hassio/touchscreen_hrv/filter_replacement_needed";
static const char* T_HOUSE_TEMP      = "hassio/touchscreen_hrv/house_temp/state";
static const char* T_HOUSE_HUM       = "hassio/touchscreen_hrv/house_humidity/state";
static const char* T_SETPOINT_STATE  = "hassio/touchscreen_hrv/setpoint/state";
static const char* T_SETPOINT_CMD    = "hassio/touchscreen_hrv/setpoint/set";
static const char* T_ROOF_TEMP       = "hassio/touchscreen_hrv/roof_temp/state";
static const char* T_POWER_STATE     = "hassio/touchscreen_hrv/power/state";
static const char* T_POWER_CMD       = "hassio/touchscreen_hrv/power/set";
static const char* T_BOOST_CMD       = "hassio/touchscreen_hrv/boost/set";
static const char* T_AVAIL           = "hassio/touchscreen_hrv/status";
static const char* T_BOOST_REMAIN_S  = "hassio/touchscreen_hrv/boost_remaining_s/state";
static const char* T_BOOST_TOTAL_S   = "hassio/touchscreen_hrv/boost_total_s/state";
static const char* T_CTRL_DEBUG      = "hassio/touchscreen_hrv/control_debug";

// Optional override publish
static const char* T_ROOF_HUM        = "hassio/touchscreen_hrv/roof_humidity/state";

// ===== Runtime state =====
String sta_ssid = WIFI_SSID_DEF, sta_pass = WIFI_PASSWORD_DEF;
String mqtt_host = MQTT_HOST_DEF;
uint16_t mqtt_port = MQTT_PORT_DEF;
String mqtt_user = MQTT_USER_DEF, mqtt_pass = MQTT_PASS_DEF;

String MQTT_CLIENTID;

WiFiClient wifiClient;
PubSubClient mqtt(wifiClient);
ESP8266WebServer web(80);

// Web flags
static bool ap_mode = false;
static bool web_started = false;
static bool mdns_started = false;

// Sensing/control
static float  last_house_temp = 255;   // 255 = unknown
static float  last_roof_temp  = 255;
static float  last_house_hum  = NAN;
static float  last_roof_hum   = NAN;
static int    last_fan_speed  = 255;   // actual fan (if reported)
static int    target_percent  = 30;
static int    last_nonzero_percent = 30;
static float  setpoint_c      = 18.0f;

static bool   power_off   = false;
static bool   boost_active = false;
static uint32_t boost_duration_ms = 5UL * 60UL * 1000UL;  // default 5 min
static uint32_t boost_end_ms = 0;

static bool   auto_mode = true;
static uint32_t manual_hold_ms = 20UL * 60UL * 1000UL; // default 20 min
static uint32_t manual_hold_until_ms = 0;

static int hrv_days_remaining = 730;
static long filter_last_epoch_day = -1;

static uint32_t last_clock_ms = 0;
static uint32_t last_sent_ms = 0;
static uint32_t ts_house = 0, ts_roof = 0, ts_fan = 0;
static const uint32_t sensor_timeout_ms = 15000;

// Auto tunables
static const float SP_TOL_C            = 0.5f;
static const float ROOF_HELP_DEADBAND  = 0.3f;
static const int   MIN_TRICKLE         = 10;
static const int   MIN_HELP_SPEED      = 20;
static const float GAIN_PCT_PER_C      = 12.0f;
static const int   NEAR_SP_MAX         = 30;
static const int   UNKNOWN_FAN_FALLBACK= 30;
static int         last_auto_percent   = -1;

// Overrides window
static const uint32_t OVERRIDE_FRESH_MS = 60000;
static uint32_t ts_in_house_temp_ms = 0;
static uint32_t ts_in_roof_temp_ms  = 0;
static uint32_t ts_in_house_hum_ms  = 0;
static uint32_t ts_in_roof_hum_ms   = 0;

// Override IN topics (persisted)
String mqtt_in_house_temp_topic;
String mqtt_in_house_hum_topic;
String mqtt_in_roof_temp_topic;
String mqtt_in_roof_hum_topic;

// Control debug
static String last_ctrl_debug = "";

// ===== LittleFS “NVS” helpers =====
static String fs_read(const char* path){
File f = LittleFS.open(path, "r");
if (!f) return "";
String s = f.readString();
f.close();
return s;
}
static void fs_write(const char* path, const String& s){
File f = LittleFS.open(path, "w");
if (!f) return;
f.print(s);
f.close();
}
static long json_find_int(const String& s, const char* key, long defv){
String k = """ + String(key) + """;
int i = s.indexOf(k); if (i<0) return defv;
i = s.indexOf(':', i); if (i<0) return defv;
char* e=nullptr; long v = strtol(s.c_str()+i+1, &e, 10);
if (e == s.c_str()+i+1) return defv;
return v;
}
static float json_find_float(const String& s, const char* key, float defv){
String k = """ + String(key) + """;
int i = s.indexOf(k); if (i<0) return defv;
i = s.indexOf(':', i); if (i<0) return defv;
char* e=nullptr; float v = strtof(s.c_str()+i+1, &e);
if (e == s.c_str()+i+1) return defv;
return v;
}
static String json_find_str(const String& s, const char* key, const String& defv){
String k = """ + String(key) + """;
int i = s.indexOf(k); if (i<0) return defv;
i = s.indexOf(':', i); if (i<0) return defv;
int q1 = s.indexOf('"', i+1);
int q2 = (q1>=0) ? s.indexOf('"', q1+1) : -1;
if (q1<0 || q2<0) return defv;
return s.substring(q1+1, q2);
}

// Persist/Load settings
static void load_settings(){
// main.json
String js = fs_read("/main.json");
if (js.length()){
setpoint_c      = json_find_float(js, "setpoint", setpoint_c);
hrv_days_remaining = (int)json_find_int(js, "filter_days", hrv_days_remaining);
filter_last_epoch_day = json_find_int(js, "last_day", filter_last_epoch_day);
int bm = (int)json_find_int(js, "boost_min", 5);
int hm = (int)json_find_int(js, "hold_min", 20);
bm = constrain(bm, 1, 240); hm = constrain(hm, 1, 240);
boost_duration_ms = (uint32_t)bm * 60000UL;
manual_hold_ms    = (uint32_t)hm * 60000UL;
}
// wifi.json
js = fs_read("/wifi.json");
if (js.length()){
sta_ssid = json_find_str(js, "ssid", sta_ssid);
sta_pass = json_find_str(js, "pass", sta_pass);
}
// mqtt.json
js = fs_read("/mqtt.json");
if (js.length()){
mqtt_host = json_find_str(js, "host", mqtt_host);
mqtt_port = (uint16_t)json_find_int(js, "port", mqtt_port);
mqtt_user = json_find_str(js, "user", mqtt_user);
mqtt_pass = json_find_str(js, "pass", mqtt_pass);
}
// overrides.json
js = fs_read("/overrides.json");
if (js.length()){
mqtt_in_house_temp_topic = json_find_str(js, "in_ht", "");
mqtt_in_house_hum_topic  = json_find_str(js, "in_hh", "");
mqtt_in_roof_temp_topic  = json_find_str(js, "in_rt", "");
mqtt_in_roof_hum_topic   = json_find_str(js, "in_rh", "");
}
}
static void save_main(){
String js="{";
js += ""setpoint":" + String(setpoint_c,1) + ",";
js += ""filter_days":" + String(hrv_days_remaining) + ",";
js += ""last_day":" + String(filter_last_epoch_day) + ",";
js += ""boost_min":" + String((int)(boost_duration_ms/60000UL)) + ",";
js += ""hold_min":"  + String((int)(manual_hold_ms/60000UL));
js += "}";
fs_write("/main.json", js);
}
static void save_wifi(){
String js="{"ssid":""+sta_ssid+"","pass":""+sta_pass+""}";
fs_write("/wifi.json", js);
}
static void save_mqtt(){
String js="{"host":""+mqtt_host+"","port":"+String(mqtt_port)+","user":""+mqtt_user+"","pass":""+mqtt_pass+""}";
fs_write("/mqtt.json", js);
}
static void save_overrides(){
String js="{";
js += ""in_ht":""+mqtt_in_house_temp_topic+"",";
js += ""in_hh":""+mqtt_in_house_hum_topic+"",";
js += ""in_rt":""+mqtt_in_roof_temp_topic+"",";
js += ""in_rh":""+mqtt_in_roof_hum_topic+""";
js += "}";
fs_write("/overrides.json", js);
}

// ===== Helpers =====
static inline String human_uptime(){
uint32_t s = millis()/1000UL; uint32_t d=s/86400UL; s%=86400UL;
uint32_t h=s/3600UL; s%=3600UL; uint32_t m=s/60UL; s%=60UL;
String out; if (d) out+=String(d)+"d "; if (h) out+=String(h)+"h ";
if (m) out+=String(m)+"m "; out+=String(s)+"s"; return out;
}
static inline String current_mode(){
if (power_off)    return "Off";
if (boost_active) return "Burnt Toast";
if (target_percent <= 12) return "Trickle";
if (last_house_temp!=255 && last_roof_temp!=255){
float err = setpoint_c - last_house_temp;
if (fabsf(err) <= SP_TOL_C) return "Hold";
float roof_delta = last_roof_temp - last_house_temp;
bool heating = err>0;
bool helpful = (heating && roof_delta> ROOF_HELP_DEADBAND) ||
(!heating && roof_delta<-ROOF_HELP_DEADBAND);
if (helpful) return heating ? "Heating" : "Cooling";
}
return "Ventilate";
}
static inline int boost_remaining_s(){
if (!boost_active) return 0;
int32_t ms_left = (int32_t)(boost_end_ms - millis());
return (ms_left>0) ? (ms_left/1000) : 0;
}

// ===== HRV bus helpers (SoftwareSerial) =====
static uint32_t last_tx_ms = 0, last_rx_any_ms = 0;

static void hrv_write_bytes(const uint8_t* b, size_t n){
for (size_t i=0;i<n;i++){ HRV.write(b[i]); }
HRV.flush();
}
static void send_frame(const uint8_t* body, size_t n){
// inter-frame gap ~140ms
uint32_t gap = millis() - last_tx_ms; if (gap < 140) delay(140-gap);
uint8_t sum = 0; for (size_t i=0;i<n;i++) sum -= body[i];
uint8_t start=0x7E, end=0x7E;
HRV.write(start); hrv_write_bytes(body,n); HRV.write(sum); HRV.write(end);
last_tx_ms = millis();
}
static void send2(uint8_t a,uint8_t b){ uint8_t x[]{a,b}; send_frame(x,sizeof(x)); }
static void send4(uint8_t a,uint8_t b,uint8_t c,uint8_t d){ uint8_t x[]{a,b,c,d}; send_frame(x,sizeof(x)); }
static void send6(uint8_t a,uint8_t b,uint8_t c,uint8_t d,uint8_t e,uint8_t f){ uint8_t x[]{a,b,c,d,e,f}; send_frame(x,sizeof(x)); }

static void send_fan_now(int p){
p = constrain(p, 0, 100);
uint8_t code = (p<=30) ? 0x4E : (p<=75 ? 0x4F : 0x50);
uint8_t body[] = {0x31,0x01,code,(uint8_t)p,0x1E,0x84,0xF0};
send_frame(body,sizeof(body));
last_sent_ms = millis(); ts_fan = last_sent_ms;
if (mqtt.connected()) mqtt.publish(T_FAN_PERCENT, String(p).c_str(), false); // non-retained
}
static void send_fan_quiet(int p){
p = constrain(p, 0, 100);
uint8_t code = (p<=30) ? 0x4E : (p<=75 ? 0x4F : 0x50);
uint8_t body[] = {0x31,0x01,code,(uint8_t)p,0x1E,0x84,0xF0};
send_frame(body,sizeof(body));
last_sent_ms = millis(); ts_fan = last_sent_ms;
}

static void boot_handshake(){
send4(0x36,0x00,0x00,0x00); delay(200);
send4(0x36,0x00,0x00,0x00); delay(200);
send4(0x36,0x00,0x00,0x00); delay(250);
send6(0x37,0x01,0x6A,0x00,0x1E,0x84); delay(180);
send2(0x34,0xE3); delay(120);
send2(0x33,0xC3); delay(120);
send2(0x43,0xC3); delay(120);
send2(0x35,0x83);
}

static bool got_roof_once = false;
static uint32_t last_probe_ms = 0;

static void process_uart(){
static std::vector<uint8_t> frame;
while (HRV.available()){
uint8_t b = (uint8_t)HRV.read();

if (frame.empty()){ if (b==0x7E) frame.push_back(b); continue; }  
frame.push_back(b);  

if (b==0x7E && frame.size()>=7){  
  size_t cks = frame.size()-2; int sum=0;  
  for (size_t i=1;i<cks;i++) sum -= frame[i];  
  bool ok = ((uint8_t)sum == frame[cks]);  
  if (ok){  
    last_rx_any_ms = millis();  
    uint8_t t = frame[1];  

    if (t==0x31 && frame.size()==10){  
      uint16_t raw = (frame[2]<<8) | frame[3];  
      float tmpc = raw*0.0625f;  
      if (tmpc>=0 && tmpc<=45){  
        bool prefer_override = (millis()-ts_in_house_temp_ms)<OVERRIDE_FRESH_MS;  
        if (!prefer_override && !sht_ok){  
          last_house_temp = roundf(tmpc*10)/10.0f;  
          ts_house = millis();  
          if (mqtt.connected()) mqtt.publish(T_HOUSE_TEMP, String(last_house_temp,1).c_str(), true);  
        }  
      }  
      int fan = frame[4];  
      if (fan>=0 && fan<=100){ last_fan_speed = fan; ts_fan = millis(); }  

    } else if (t==0x30 && frame.size()==7){  
      uint16_t raw = (frame[2]<<8) | frame[3];  
      float tmpc = raw*0.0625f;  
      if (tmpc>=0 && tmpc<=45){  
        bool prefer_override = (millis()-ts_in_roof_temp_ms)<OVERRIDE_FRESH_MS;  
        if (!prefer_override){  
          last_roof_temp = roundf(tmpc*10)/10.0f; ts_roof = millis(); got_roof_once = true;  
          if (mqtt.connected()) mqtt.publish(T_ROOF_TEMP, String(last_roof_temp,1).c_str(), true);  
        } else got_roof_once = true;  
      }  
    }  
  }  
  frame.clear();  
}  
if (frame.size()>24) frame.clear();

}
}

// ===== Auto control =====
static void auto_control_task(bool force_send=false){
if (power_off || boost_active) return;

if (!auto_mode){
if ((int32_t)(millis()-manual_hold_until_ms) < 0) return;
auto_mode = true;
}

if (last_house_temp==255 || last_roof_temp==255){
int p = UNKNOWN_FAN_FALLBACK;
last_ctrl_debug = String("auto: set=")+String(setpoint_c,1)+
" house="+(last_house_temp==255?"unk":String(last_house_temp,1))+
" roof="+(last_roof_temp==255?"unk":String(last_roof_temp,1))+
" -> "+String(p)+"%";
if (mqtt.connected()) mqtt.publish(T_CTRL_DEBUG, last_ctrl_debug.c_str(), true);

if (!force_send && abs(p-target_percent)<2 && abs(p-last_auto_percent)<2) return;  
last_auto_percent = p; target_percent=p; if (p>0) last_nonzero_percent=p;  
send_fan_now(p);  
return;

}

float err = setpoint_c - last_house_temp; // + => warmer
float abs_err = fabsf(err);
float roof_delta = last_roof_temp - last_house_temp;
int p = MIN_TRICKLE;

if (abs_err <= SP_TOL_C) {
p = MIN_TRICKLE;
} else {
bool heating = (err>0);
bool helpful = (heating && roof_delta>ROOF_HELP_DEADBAND) ||
(!heating && roof_delta<-ROOF_HELP_DEADBAND);
if (!helpful) {
p = MIN_TRICKLE;
} else {
float mag = fabsf(roof_delta) - ROOF_HELP_DEADBAND;
float raw = MIN_HELP_SPEED + GAIN_PCT_PER_C * mag;
if (abs_err < 1.0f) raw = fminf(raw, (float)NEAR_SP_MAX);
p = constrain((int)roundf(raw), MIN_TRICKLE, 100);
}
}
if (!force_send && abs(p-target_percent)<2 && abs(p-last_auto_percent)<2) return;
last_auto_percent = p; target_percent = p; if (p>0) last_nonzero_percent=p;
send_fan_now(p);
}

// ===== Power/Boost/Setpoint =====
static void apply_power_off(){
power_off = true;
if (boost_active) boost_active=false;
target_percent = 0;
send_fan_now(0);
if (mqtt.connected()) mqtt.publish(T_POWER_STATE, "OFF", true);
}
static void apply_power_on(){
power_off = false;
auto_mode = true; manual_hold_until_ms = 0;
auto_control_task(true);
if (mqtt.connected()) mqtt.publish(T_POWER_STATE, "ON", true);
}
static void start_burnt_toast(){
if (power_off || boost_active) return;
boost_active = true; boost_end_ms = millis()+boost_duration_ms;
if (mqtt.connected()){
mqtt.publish(T_BOOST_ACTIVE,"ON",true);
mqtt.publish(T_BOOST_TOTAL_S, String((int)(boost_duration_ms/1000)).c_str(), true);
mqtt.publish(T_BOOST_REMAIN_S, String((int)(boost_duration_ms/1000)).c_str(), true);
}
target_percent = 100; last_nonzero_percent = 100; auto_mode=false;
manual_hold_until_ms = millis()+manual_hold_ms;
send_fan_now(100);
}
static void stop_burnt_toast(){
if (!boost_active) return;
boost_active=false;
if (mqtt.connected()) { mqtt.publish(T_BOOST_ACTIVE,"OFF",true); mqtt.publish(T_BOOST_REMAIN_S,"0",true); }
if (!power_off){
auto_mode=false; manual_hold_until_ms = millis()+manual_hold_ms;
target_percent=30; last_nonzero_percent=30;
send_fan_now(30);
}
}

static inline void save_setpoint(float v){
setpoint_c = constrain(v, 5.0f, 35.0f);
// persist
save_main();
if (mqtt.connected()) mqtt.publish(T_SETPOINT_STATE, String(setpoint_c,1).c_str(), true);
if (!power_off && !boost_active){ auto_mode = true; manual_hold_until_ms = 0; auto_control_task(true); }
}

// ===== MQTT =====
static void publish_discovery(){
String dev = F(""identifiers":["hrv-keypad"],"manufacturer":"Figjam","model":"HRV Keypad","name":"HRV","sw_version":"1.0"");
String avail = String(F(""availability":[{"topic":"")) + T_AVAIL + F("","payload_available":"online","payload_not_available":"offline"}]");
auto pub=[&](const char* t, const String& j){ mqtt.publish(t, j.c_str(), true); };

pub("homeassistant/sensor/hrv_house_temp/config",
String("{"name":"HRV House Temp","unique_id":"hrv_house_temp","state_topic":"")+T_HOUSE_TEMP+
"","unit_of_measurement":"°C","device_class":"temperature","state_class":"measurement","+
avail+","device":{"+dev+"}}");

pub("homeassistant/sensor/hrv_house_humidity/config",
String("{"name":"HRV House Humidity","unique_id":"hrv_house_humidity","state_topic":"")+T_HOUSE_HUM+
"","unit_of_measurement":"%","device_class":"humidity","state_class":"measurement","+
avail+","device":{"+dev+"}}");

pub("homeassistant/sensor/hrv_roof_temp/config",
String("{"name":"HRV Roof Temp","unique_id":"hrv_roof_temp","state_topic":"")+T_ROOF_TEMP+
"","unit_of_measurement":"°C","device_class":"temperature","state_class":"measurement","+
avail+","device":{"+dev+"}}");

pub("homeassistant/sensor/hrv_roof_humidity/config",
String("{"name":"HRV Roof Humidity","unique_id":"hrv_roof_humidity","state_topic":"")+T_ROOF_HUM+
"","unit_of_measurement":"%","device_class":"humidity","state_class":"measurement","+
avail+","device":{"+dev+"}}");

pub("homeassistant/sensor/hrv_fan_actual/config",
String("{"name":"HRV Fan Actual","unique_id":"hrv_fan_actual","state_topic":"")+T_FAN_PERCENT+
"","unit_of_measurement":"%","icon":"mdi:fan","state_class":"measurement","+
avail+","device":{"+dev+"}}");

pub("homeassistant/sensor/hrv_filter_days/config",
String("{"name":"HRV Filter Days","unique_id":"hrv_filter_days","state_topic":"")+T_FILTER_DAYS+
"","unit_of_measurement":"d","state_class":"measurement","+
avail+","device":{"+dev+"}}");

pub("homeassistant/sensor/hrv_filter_life/config",
String("{"name":"HRV Filter Life","unique_id":"hrv_filter_life","state_topic":"")+T_FILTER_LIFE+
"","unit_of_measurement":"%","state_class":"measurement","+
avail+","device":{"+dev+"}}");

pub("homeassistant/binary_sensor/hrv_filter_needed/config",
String("{"name":"HRV Filter Needed","unique_id":"hrv_filter_needed","state_topic":"")+T_FILTER_NEEDED+
"","payload_on":"ON","payload_off":"OFF","device_class":"problem","+
avail+","device":{"+dev+"}}");

pub("homeassistant/binary_sensor/hrv_boost_active/config",
String("{"name":"HRV Boost Active","unique_id":"hrv_boost_active","state_topic":"")+T_BOOST_ACTIVE+
"","payload_on":"ON","payload_off":"OFF","+
avail+","device":{"+dev+"}}");

pub("homeassistant/sensor/hrv_boost_remaining/config",
String("{"name":"HRV Boost Remaining","unique_id":"hrv_boost_remaining","state_topic":"")+T_BOOST_REMAIN_S+
"","unit_of_measurement":"s","icon":"mdi:timer-outline","state_class":"measurement","+
avail+","device":{"+dev+"}}");

pub("homeassistant/switch/hrv_power/config",
String("{"name":"HRV Power","unique_id":"hrv_power","command_topic":"")+T_POWER_CMD+
"","state_topic":""+T_POWER_STATE+"","payload_on":"ON","payload_off":"OFF","+
avail+","device":{"+dev+"}}");

pub("homeassistant/switch/hrv_boost/config",
String("{"name":"HRV Boost","unique_id":"hrv_boost","command_topic":"")+T_BOOST_CMD+
"","state_topic":""+T_BOOST_ACTIVE+"","payload_on":"ON","payload_off":"OFF","+
avail+","device":{"+dev+"}}");

pub("homeassistant/number/hrv_fan_percent/config",
String("{"name":"HRV Fan %","unique_id":"hrv_fan_percent","command_topic":"")+T_FAN_CMD+
"","state_topic":""+T_FAN_PERCENT+"","min":0,"max":100,"step":1,"+
""unit_of_measurement":"%","icon":"mdi:fan","+
avail+","device":{"+dev+"}}");

pub("homeassistant/number/hrv_filter_days_remaining/config",
String("{"name":"HRV Filter Days Remaining","unique_id":"hrv_filter_days_remaining","command_topic":"")+C_FILTER_DAYS_SET+
"","state_topic":""+T_FILTER_DAYS+"","min":0,"max":2000,"step":1,"+
""unit_of_measurement":"d","+
avail+","device":{"+dev+"}}");

pub("homeassistant/number/hrv_setpoint_c/config",
String("{"name":"HRV Setpoint","unique_id":"hrv_setpoint_c","command_topic":"")+T_SETPOINT_CMD+
"","state_topic":""+T_SETPOINT_STATE+"","min":5,"max":35,"step":1,"+
""unit_of_measurement":"°C","icon":"mdi:thermostat","+
avail+","device":{"+dev+"}}");
}

static void mqtt_callback(char* topic, byte* payload, unsigned int len){
String t(topic); String x; x.reserve(len); for (unsigned int i=0;i<len;i++) x+=(char)payload[i]; x.trim();

// Overrides
if (mqtt_in_house_temp_topic.length() && t==mqtt_in_house_temp_topic){
float v = x.toFloat(); if (v>-50 && v<80){
last_house_temp = roundf(v10)/10.0f; ts_house=millis(); ts_in_house_temp_ms=millis();
if (mqtt.connected()) mqtt.publish(T_HOUSE_TEMP, String(last_house_temp,1).c_str(), true);
} return;
}
if (mqtt_in_house_hum_topic.length() && t==mqtt_in_house_hum_topic){
float v = x.toFloat(); if (v>=0 && v<=100){
last_house_hum = roundf(v10)/10.0f; ts_in_house_hum_ms=millis();
if (mqtt.connected()) mqtt.publish(T_HOUSE_HUM, String(last_house_hum,1).c_str(), true);
} return;
}
if (mqtt_in_roof_temp_topic.length() && t==mqtt_in_roof_temp_topic){
float v = x.toFloat(); if (v>-50 && v<80){
last_roof_temp = roundf(v10)/10.0f; ts_roof=millis(); ts_in_roof_temp_ms=millis();
if (mqtt.connected()) mqtt.publish(T_ROOF_TEMP, String(last_roof_temp,1).c_str(), true);
} return;
}
if (mqtt_in_roof_hum_topic.length() && t==mqtt_in_roof_hum_topic){
float v = x.toFloat(); if (v>=0 && v<=100){
last_roof_hum = roundf(v10)/10.0f; ts_in_roof_hum_ms=millis();
if (mqtt.connected()) mqtt.publish(T_ROOF_HUM, String(last_roof_hum,1).c_str(), true);
} return;
}

// Core commands
if (t==T_POWER_CMD){
if (x.equalsIgnoreCase("ON"))  { if (power_off) apply_power_on();  }
if (x.equalsIgnoreCase("OFF")) { if (!power_off) apply_power_off(); }
if (mqtt.connected()) mqtt.publish(T_POWER_STATE, power_off?"OFF":"ON", true);
return;
}
if (t==T_BOOST_CMD){
if (x.equalsIgnoreCase("ON")) start_burnt_toast();
if (x.equalsIgnoreCase("OFF")) stop_burnt_toast();
return;
}
if (t==C_FILTER_DAYS_SET){
int d = constrain(x.toInt(), 0, 2000);
hrv_days_remaining = d;
time_t now = time(nullptr);
if (now>0){ filter_last_epoch_day = (long)(now/86400); }
int pct = (int)lround(hrv_days_remaining * 100.0 / 730.0);
if (mqtt.connected()){
mqtt.publish(T_FILTER_DAYS, String(hrv_days_remaining).c_str(), true);
mqtt.publish(T_FILTER_LIFE, String(pct).c_str(), true);
mqtt.publish(T_FILTER_NEEDED, (pct<=0)?"ON":"OFF", true);
}
save_main();
return;
}
if (t==T_FAN_CMD){
if (power_off || boost_active) return;
int p = constrain(x.toInt(), 0, 100);
if (p==target_percent) return;
target_percent=p; if (p>0) last_nonzero_percent=p;
send_fan_now(p);
auto_mode=false; manual_hold_until_ms = millis()+manual_hold_ms;
return;
}
if (t==T_SETPOINT_CMD){
float v = constrain(x.toFloat(), 5.0f, 35.0f);
if (fabsf(v - setpoint_c) > 0.01f) save_setpoint(v);
return;
}
}

static uint32_t next_mqtt_try_ms = 0;

static void mqtt_loop_task(){
if (!WiFi.isConnected() || ap_mode){ return; }
if (mqtt.connected()){ mqtt.loop(); return; }
if (millis() < next_mqtt_try_ms) return;
if (!mqtt_host.length()){ next_mqtt_try_ms = millis()+5000; return; }

mqtt.setServer(mqtt_host.c_str(), mqtt_port);
mqtt.setCallback(mqtt_callback);

if (mqtt.connect(MQTT_CLIENTID.c_str(), mqtt_user.c_str(), mqtt_pass.c_str(), T_AVAIL, 1, true, "offline")){
mqtt.subscribe(T_FILTER_DAYS,1);
mqtt.subscribe(T_FILTER_LIFE,1);
mqtt.subscribe(C_FILTER_DAYS_SET);
mqtt.subscribe(T_FAN_CMD,1);
mqtt.subscribe(T_SETPOINT_CMD,1);
mqtt.subscribe(T_POWER_CMD,1);
mqtt.subscribe(T_BOOST_CMD,1);

if (mqtt_in_house_temp_topic.length()) mqtt.subscribe(mqtt_in_house_temp_topic.c_str(),0);  
if (mqtt_in_house_hum_topic.length())  mqtt.subscribe(mqtt_in_house_hum_topic.c_str(),0);  
if (mqtt_in_roof_temp_topic.length())  mqtt.subscribe(mqtt_in_roof_temp_topic.c_str(),0);  
if (mqtt_in_roof_hum_topic.length())   mqtt.subscribe(mqtt_in_roof_hum_topic.c_str(),0);  

mqtt.publish(T_AVAIL, "online", true);  

// Republish retained state  
mqtt.publish(T_SETPOINT_STATE, String(setpoint_c,1).c_str(), true);  
mqtt.publish(T_BOOST_TOTAL_S, String((int)(boost_duration_ms/1000)).c_str(), true);  
mqtt.publish(T_BOOST_REMAIN_S, String(boost_remaining_s()).c_str(), true);  
if (last_house_temp!=255) mqtt.publish(T_HOUSE_TEMP, String(last_house_temp,1).c_str(), true);  
if (!isnan(last_house_hum)) mqtt.publish(T_HOUSE_HUM, String(last_house_hum,1).c_str(), true);  
mqtt.publish(T_POWER_STATE, power_off?"OFF":"ON", true);  
if (last_roof_temp!=255) mqtt.publish(T_ROOF_TEMP, String(last_roof_temp,1).c_str(), true);  
mqtt.publish(T_FAN_PERCENT, String(target_percent).c_str(), true);  

publish_discovery();

}
next_mqtt_try_ms = millis()+3000;
}

// ===== Web UI (same HTML as your ESP32 page, trimmed for 8266) =====
static const char INDEX_HTML[] PROGMEM = R"HTML(
<!doctype html><html><head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">

<title>HRV Keypad</title>  
<style>  
:root { --accent:#0078d7; --bg:#f7f9fb; --card:#fff; --text:#333; }  
body{font-family:system-ui,Arial;margin:0;background:var(--bg);color:var(--text)}  
header{background:var(--accent);color:#fff;padding:12px 16px}  
h2{margin:0;font-size:20px}  
main{padding:16px;max-width:600px;margin:auto}  
.row{margin:10px 0}  
.val{font-weight:600}  
.card{background:var(--card);border-radius:10px;padding:14px 16px;box-shadow:0 2px 5px rgba(0,0,0,.08);margin-bottom:16px}  
fieldset{border:none;padding:0;margin:0}  
legend{font-weight:bold;margin-bottom:6px;color:var(--accent)}  
label{display:block;margin:6px 0 2px;font-size:14px}  
input,button,select{font:inherit;padding:8px;border:1px solid #ccc;border-radius:6px;width:100%;box-sizing:border-box}  
input[type=file]{border:none}  
.btn{display:inline-block;background:var(--accent);color:#fff;border:none;padding:10px 16px;margin:4px 2px;border-radius:6px;cursor:pointer;transition:.2s}  
.btn:hover{background:#005a9e}.btn:active{background:#004578}  
.range{width:100%;-webkit-appearance:none;height:6px;border-radius:3px;background:#ddd;outline:none}  
.range::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);cursor:pointer}  
.ok{color:#0a0}.bad{color:#c00}  
small{color:#666}  
summary{cursor:pointer;padding:6px 0;font-weight:bold;color:var(--accent)}  
</style></head>  
<body>  
<header><h2>HRV Keypad</h2></header>  
<main>  
<div class="card">  
  <div class=row>IP: <span id=ip class=val></span> | RSSI: <span id=rssi class=val></span>dBm</div>  
  <div class=row>WiFi: <span id=wf class=val></span> | SSID: <span id=ssid class=val></span> | MAC: <span id=mac class=val></span></div>  
  <div class=row>Time: <span id=time class=val></span> | Mode: <span id=mode class=val></span></div>  
  <div class=row>House: <span id=house class=val></span>°C | Hum: <span id=hum class=val></span>% | Roof: <span id=roof class=val></span>°C</div>  
  <div class=row>Fan Target: <span id=fanT class=val></span>% | Actual: <span id=fanA class=val></span>%</div>  
  <div class=row>Filter: <span id=filter class=val></span> (<span id=filterPct></span>%)</div>  
  <div class=row>  
    <button class=btn id=powerBtn>Toggle Power</button>  
    <button class=btn id=boostBtn>Burnt Toast</button> <small id=btinfo></small>  
  </div>  
  <div class=row><input id=fanRange class=range type=range min=0 max=100 step=1></div>  
</div>  <details class="card">  
  <summary>Timer Settings</summary>  
  <fieldset>  
    <legend>Durations</legend>  
    <label>Burnt Toast duration</label>  
    <select id="boostMin"><option>5</option><option>10</option><option>30</option><option value="60">1 hour</option><option value="120">2 hours</option><option value="240">4 hours</option></select>  
    <label>Manual override hold</label>  
    <select id="holdMin"><option>5</option><option>10</option><option selected>20</option><option>30</option><option value="60">1 hour</option><option value="120">2 hours</option></select>  
  </fieldset>  
  <div class="row"><button class="btn" id="tmrSave">Save Timers</button><span id="tmrMsg"></span></div>  
  <small>Changes affect new Boosts and new manual overrides.</small>  
</details>  <details class="card">  
  <summary>Sensor Overrides (optional)</summary>  
  <fieldset>  
    <legend>Incoming MQTT topics (numeric payloads)</legend>  
    <label>House Temp topic</label><input id="in_ht" placeholder="e.g. home/inside/temperature">  
    <label>House Humidity topic</label><input id="in_hh" placeholder="e.g. home/inside/humidity">  
    <label>Roof Temp topic</label><input id="in_rt" placeholder="e.g. roof/probe/temperature">  
    <label>Roof Humidity topic</label><input id="in_rh" placeholder="(optional)">  
  </fieldset>  
  <div class="row"><button class="btn" id="ovrSave">Save Overrides</button><span id="ovrMsg"></span></div>  
  <small>Leave any field blank to disable that override. Values are mirrored to the standard state topics.</small>  
</details>  <details class="card">  
  <summary>MQTT Settings</summary>  
  <fieldset>  
    <legend>Broker</legend>  
    <label>Host/IP</label><input id=mqtthost placeholder="host">  
    <label>Port</label><input id=mqttport type=number min=1 max=65535 placeholder="1883">  
  </fieldset>  
  <fieldset>  
    <legend>Auth</legend>  
    <label>User</label><input id=mqttuser placeholder="user">  
    <label>Password</label><input id=mqttpass type=password placeholder="password">  
  </fieldset>  
  <div class=row><button class=btn id=mqttSave>Save & Reconnect</button><span id=mqttMsg></span></div>  
</details>  <details class="card">  
  <summary>Wi-Fi Settings</summary>  
  <fieldset>  
    <legend>Station</legend>  
    <label>SSID</label><input id=wfssid placeholder="Wi-Fi SSID">  
    <label>Password</label><input id=wfpw type=password placeholder="Wi-Fi password">  
  </fieldset>  
  <div class=row><button class=btn id=wfSave>Save & Reconnect</button><span id=wfMsg></span></div>  
  <small>If connection fails, device will fall back to AP "<b>HRV-Keypad</b>"</small>  
</details>  <details class="card">  
  <summary>Firmware Update (OTA)</summary>  
  <fieldset>  
    <legend>Upload .bin</legend>  
    <form method="POST" action="/ota" enctype="multipart/form-data" onsubmit="setTimeout(()=>location.reload(),5000)">  
      <input type="file" name="update" required>  
      <button class="btn" type="submit">Upload & Flash</button>  
    </form>  
    <small>After upload the device will reboot automatically.</small>  
  </fieldset>  
  <div class=row><a class="btn" href="/ota">Open full OTA page</a></div>  
</details>  
</main>  <script>  
async function q(p){return fetch(p).then(r=>r.json())}  
function g(id){return document.getElementById(id)}  
  
async function loadMQTT(){try{const m=await q('/mqtt');  
  g('mqtthost').value=m.host||''; g('mqttport').value=m.port||'1883';  
  g('mqttuser').value=m.user||''; g('mqttpass').value=m.pass||'';}catch(e){}}  
async function loadWiFi(){try{const w=await q('/wifi');  
  g('wfssid').value=w.ssid||''; g('wfpw').value=w.pass||'';}catch(e){}}  
async function saveMQTT(){  
  const host=encodeURIComponent(g('mqtthost').value.trim());  
  const port=encodeURIComponent(g('mqttport').value.trim());  
  const user=encodeURIComponent(g('mqttuser').value.trim());  
  const pass=encodeURIComponent(g('mqttpass').value);  
  try{const r=await q(`/mqtt?host=${host}&port=${port}&user=${user}&pass=${pass}`);  
    g('mqttMsg').textContent=r.ok?'Saved. Reconnecting…':'Failed';  
    setTimeout(()=>g('mqttMsg').textContent='',2000);}catch(e){g('mqttMsg').textContent='Error';}}  
async function saveWiFi(){  
  const ssid=encodeURIComponent(g('wfssid').value.trim());  
  const pass=encodeURIComponent(g('wfpw').value);  
  try{const r=await q(`/wifi?ssid=${ssid}&pass=${pass}`);  
    g('wfMsg').textContent=r.ok?'Saved. Reconnecting…':'Failed';  
    setTimeout(()=>g('wfMsg').textContent='',2500);}catch(e){g('wfMsg').textContent='Error';}}  
g('mqttSave').onclick=saveMQTT; g('wfSave').onclick=saveWiFi;  
  
async function loadOverrides(){try{const o=await q('/mqtt_overrides');  
  g('in_ht').value=o.in_ht||''; g('in_hh').value=o.in_hh||'';  
  g('in_rt').value=o.in_rt||''; g('in_rh').value=o.in_rh||'';}catch(e){}}  
async function saveOverrides(){  
  const in_ht=encodeURIComponent(g('in_ht').value.trim());  
  const in_hh=encodeURIComponent(g('in_hh').value.trim());  
  const in_rt=encodeURIComponent(g('in_rt').value.trim());  
  const in_rh=encodeURIComponent(g('in_rh').value.trim());  
  try{const r=await q(`/mqtt_overrides?in_ht=${in_ht}&in_hh=${in_hh}&in_rt=${in_rt}&in_rh=${in_rh}`);  
    g('ovrMsg').textContent=r.ok?'Saved. Re-subscribing…':'Failed';  
    setTimeout(()=>g('ovrMsg').textContent='',2500);}catch(e){g('ovrMsg').textContent='Error';}}  
g('ovrSave').onclick=saveOverrides;  
  
async function loadTimers(){try{const t=await q('/timers');  
  if(typeof t.boost_min!=='undefined') g('boostMin').value=String(t.boost_min);  
  if(typeof t.hold_min!=='undefined')  g('holdMin').value=String(t.hold_min);}catch(e){}}  
async function saveTimers(){  
  const bm=encodeURIComponent(g('boostMin').value);  
  const hm=encodeURIComponent(g('holdMin').value);  
  try{const r=await q(`/timers?boost_min=${bm}&hold_min=${hm}`);  
    g('tmrMsg').textContent=r.ok?'Saved.':'Failed';  
    setTimeout(()=>g('tmrMsg').textContent='',2000);}catch(e){g('tmrMsg').textContent='Error';}}  
g('tmrSave').onclick=saveTimers;  
  
async function tick(){  
  try{const s=await q('/status');  
    g('ip').textContent=s.ip; g('rssi').textContent=s.rssi; g('wf').textContent=s.wifi_mode;  
    g('ssid').textContent=s.ssid||''; g('mac').textContent=s.mac||'';  
    g('time').textContent=s.time; g('mode').textContent=s.mode;  
    g('house').textContent=(s.house===null?'--':s.house.toFixed(1));  
    g('hum').textContent=(s.hum===null?'--':s.hum.toFixed(1));  
    g('roof').textContent=(s.roof===null?'--':s.roof.toFixed(1));  
    g('fanT').textContent=s.fan_target; g('fanA').textContent=s.fan_actual;  
    g('filter').textContent=s.filter_text;  
    g('filter').className=s.filter_text=='REPLACE'?'val bad':'val ok';  
    g('filterPct').textContent=s.filter_pct;  
    const fr=g('fanRange'); fr.disabled=s.slider_disabled;  
    if(!fr.dragging) fr.value=s.fan_target;  
    const br=s.boost_remaining_s||0,bt=s.boost_total_s||300;  
    if(s.boost&&br>0){const m=Math.floor(br/60),sec=br%60;  
      g('boostBtn').textContent=`Burnt Toast (${m}:${sec<10?'0':''}${sec})`;  
      g('btinfo').textContent=` ${Math.round(100*br/bt)}% left`;  
    }else{g('boostBtn').textContent=s.boost?'Burnt Toast (ON)':'Burnt Toast (OFF)';g('btinfo').textContent='';}  
    g('boostBtn').disabled=s.power_off;  
  }catch(e){}}  
g('powerBtn').onclick=()=>q('/api/power?toggle=1');  
g('boostBtn').onclick =()=>q('/api/boost?toggle=1');  
const fr=g('fanRange');  
fr.oninput =()=>{fr.dragging=true; g('fanT').textContent=fr.value}  
fr.onchange=()=>{fetch('/api/setfan?val='+fr.value); fr.dragging=false}  
loadMQTT(); loadWiFi(); loadOverrides(); loadTimers(); setInterval(tick,1000); tick();  
</script></body></html>  )HTML";

// Simple OTA page (same endpoints as your ESP32 version)
static const char OTA_HTML[] PROGMEM = R"OTA(
<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1">

<title>HRV OTA</title><style>body{font-family:system-ui,Arial;margin:16px}</style></head>  
<body><h3>HRV Keypad OTA Update</h3>  
<form method="POST" action="/ota" enctype="multipart/form-data"><input type="file" name="update" required>  
<input type="submit" value="Upload & Flash"></form>  
<p>After a successful upload the device will reboot automatically.</p></body></html>  
)OTA";  // ===== HTTP handlers =====
static void handle_root(){ web.send_P(200,"text/html",INDEX_HTML); }

static void handle_status(){
struct tm tmNow; char hhmm[6]="--:--";
time_t now=time(nullptr); if (now>0){ localtime_r(&now,&tmNow); strftime(hhmm,sizeof(hhmm),"%H:%M",&tmNow); }
int lifePct = (int)round(hrv_days_remaining * 100.0 / 730.0);
IPAddress ip = WiFi.isConnected()? WiFi.localIP() : WiFi.softAPIP();
String mac = WiFi.macAddress();
String wifiMode = WiFi.isConnected() ? "STA" : (ap_mode ? "AP" : "DISCONNECTED");
String ssid     = WiFi.isConnected() ? WiFi.SSID() : (ap_mode ? String(AP_SSID) : "");

String json="{";
json += ""ip":""+ip.toString()+"",";
json += ""rssi":"+String(WiFi.isConnected()?WiFi.RSSI():0)+",";
json += ""wifi_mode":""+wifiMode+"",";
json += ""ssid":""+ssid+"",";
json += ""mac":""+mac+"",";
json += ""time":""+String(hhmm)+"",";
json += ""house":"; json += (last_house_temp==255)?"null,":String(last_house_temp,1)+",";
json += ""hum":";   json += (isnan(last_house_hum))?"null,":String(last_house_hum,1)+",";
json += ""roof":";  json += (last_roof_temp==255)?"null,":String(last_roof_temp,1)+",";
json += ""power_off":" + String(power_off?"true":"false") + ",";
json += ""boost":"     + String(boost_active?"true":"false") + ",";
json += ""boost_remaining_s":" + String(boost_remaining_s()) + ",";
json += ""boost_total_s":"     + String((int)(boost_duration_ms/1000)) + ",";
json += ""slider_disabled":" + String((power_off||boost_active)?"true":"false") + ",";
json += ""auto":"     + String(auto_mode?"true":"false") + ",";
json += ""setpoint":" + String(setpoint_c,1) + ",";
json += ""fan_target":"+ String(target_percent) + ",";
json += ""fan_actual":"+ String(last_fan_speed==255 ? target_percent : last_fan_speed) + ",";
json += ""filter_pct":"+ String(lifePct) + ",";
json += ""filter_text":""+ String(lifePct<=0 ? "REPLACE" : "OK") + "",";
json += ""mode":""+ current_mode() +""";
json += "}";
web.send(200,"application/json",json);
}

static void handle_setfan(){
if (boost_active || power_off){ web.send(200,"application/json","{"ok":false}"); return; }
int p = web.hasArg("val") ? web.arg("val").toInt() : target_percent;
p = constrain(p,0,100); target_percent=p; if (p>0) last_nonzero_percent=p;
send_fan_now(p);
auto_mode=false; manual_hold_until_ms = millis()+manual_hold_ms;
web.send(200,"application/json","{"ok":true}");
}
static void handle_power(){ if (!power_off) apply_power_off(); else apply_power_on(); web.send(200,"application/json","{"ok":true}"); }
static void handle_boost(){ if (power_off){ web.send(200,"application/json","{"ok":false}"); return;} if (boost_active) stop_burnt_toast(); else start_burnt_toast(); web.send(200,"application/json","{"ok":true}"); }

static void handle_setpoint(){
if (!web.hasArg("c")){ web.send(400,"application/json","{"ok":false,"err":"missing c"}"); return; }
float v = constrain(web.arg("c").toFloat(), 5.0f, 35.0f); save_setpoint(v);
web.send(200,"application/json","{"ok":true}");
}
static void handle_auto(){
if (web.hasArg("mode")){
String m = web.arg("mode");
if (m=="manual"){ auto_mode=false; manual_hold_until_ms = millis()+manual_hold_ms; }
else { auto_mode=true; manual_hold_until_ms = 0; if (!power_off && !boost_active) auto_control_task(true); }
}
web.send(200,"application/json","{"ok":true}");
}

static void handle_mqtt_cfg(){
bool changed=false;
if (web.hasArg("host")){ String v=web.arg("host"); v.trim(); if (v.length()) {mqtt_host=v; changed=true; save_mqtt();} }
if (web.hasArg("port")){ int v=web.arg("port").toInt(); if (v>=1 && v<=65535){ mqtt_port=(uint16_t)v; changed=true; save_mqtt(); } }
if (web.hasArg("user")){ mqtt_user=web.arg("user"); changed=true; save_mqtt(); }
if (web.hasArg("pass")){ mqtt_pass=web.arg("pass"); changed=true; save_mqtt(); }
if (changed){ mqtt.disconnect(); web.send(200,"application/json","{"ok":true}"); return; }
String js="{"host":""+mqtt_host+"","port":"+String(mqtt_port)+","user":""+mqtt_user+"","pass":""+mqtt_pass+""}";
web.send(200,"application/json",js);
}
static void handle_wifi_cfg(){
bool changed=false;
if (web.hasArg("ssid")){ String v=web.arg("ssid"); v.trim(); if (v.length()){ sta_ssid=v; changed=true; save_wifi(); } }
if (web.hasArg("pass")){ sta_pass=web.arg("pass"); changed=true; save_wifi(); }
if (changed){
WiFi.disconnect(true); delay(100); ap_mode=false;
web.send(200,"application/json","{"ok":true}");
return;
}
String js="{"ssid":""+sta_ssid+"","pass":""+sta_pass+""}";
web.send(200,"application/json",js);
}
static void handle_mqtt_overrides(){
bool changed=false;
if (web.hasArg("in_ht")){ mqtt_in_house_temp_topic=web.arg("in_ht"); changed=true; }
if (web.hasArg("in_hh")){ mqtt_in_house_hum_topic =web.arg("in_hh"); changed=true; }
if (web.hasArg("in_rt")){ mqtt_in_roof_temp_topic =web.arg("in_rt"); changed=true; }
if (web.hasArg("in_rh")){ mqtt_in_roof_hum_topic  =web.arg("in_rh"); changed=true; }
if (changed){ save_overrides(); if (mqtt.connected()) mqtt.disconnect(); web.send(200,"application/json","{"ok":true}"); return; }
String js="{";
js += ""in_ht":""+mqtt_in_house_temp_topic+"",";
js += ""in_hh":""+mqtt_in_house_hum_topic+"",";
js += ""in_rt":""+mqtt_in_roof_temp_topic+"",";
js += ""in_rh":""+mqtt_in_roof_hum_topic+""}";
web.send(200,"application/json",js);
}
static void handle_timers_cfg(){
bool changed=false;
if (web.hasArg("boost_min")){ int m=constrain(web.arg("boost_min").toInt(),1,240); boost_duration_ms=(uint32_t)m60000UL; changed=true; }
if (web.hasArg("hold_min")) { int m=constrain(web.arg("hold_min").toInt(), 1,240); manual_hold_ms   =(uint32_t)m60000UL; changed=true; }
if (changed){ save_main(); if (mqtt.connected()) mqtt.publish(T_BOOST_TOTAL_S, String((int)(boost_duration_ms/1000)).c_str(), true);
web.send(200,"application/json","{"ok":true}"); return; }
String js="{"boost_min":"+String((int)(boost_duration_ms/60000UL))+","hold_min":"+String((int)(manual_hold_ms/60000UL))+"}";
web.send(200,"application/json",js);
}

// OTA
static void handle_ota_root(){ web.send_P(200,"text/html",OTA_HTML); }
static void handle_ota_upload(){
HTTPUpload& up = web.upload();
if (up.status == UPLOAD_FILE_START) {
size_t maxSketchSpace = (ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000;
if (!Update.begin(maxSketchSpace)) { Update.printError(Serial); }
} else if (up.status == UPLOAD_FILE_WRITE) {
if (Update.write(up.buf, up.currentSize) != up.currentSize) { Update.printError(Serial); }
} else if (up.status == UPLOAD_FILE_END) {
if (!Update.end(true)) { Update.printError(Serial); }
}
}
static void handle_ota_result(){
if (Update.hasError()) web.send(200,"text/plain","OTA FAILED"); else web.send(200,"text/plain","OK. Rebooting…");
delay(500); ESP.restart();
}

// ===== Wi-Fi / mDNS =====
static uint32_t wifi_begin_ms = 0;
static void start_web_if_needed(){
if (web_started) return;
web.on("/",            handle_root);
web.on("/status",      handle_status);
web.on("/api/setfan",  handle_setfan);
web.on("/api/power",   handle_power);
web.on("/api/boost",   handle_boost);
web.on("/api/setpoint",handle_setpoint);
web.on("/api/auto",    handle_auto);
web.on("/mqtt",        handle_mqtt_cfg);
web.on("/wifi",        handle_wifi_cfg);
web.on("/mqtt_overrides", handle_mqtt_overrides);
web.on("/timers",      handle_timers_cfg);
web.on("/ota", HTTP_GET,  handle_ota_root);
web.on("/ota", HTTP_POST, handle_ota_result, handle_ota_upload);
web.begin();
web_started=true;
}
static void wifi_loop_task(){
if (ap_mode){ if (!web_started) start_web_if_needed(); return; }
if (WiFi.status()==WL_CONNECTED){
if (!mdns_started){ if (MDNS.begin("hrv-keypad")) MDNS.addService("http","tcp",80); mdns_started=true; }
if (!web_started) start_web_if_needed();
return;
}
if (wifi_begin_ms==0){
WiFi.mode(WIFI_STA);
WiFi.begin(sta_ssid.c_str(), sta_pass.c_str());
wifi_begin_ms = millis();
return;
}
if (millis()-wifi_begin_ms > 8000){
WiFi.disconnect(true);
delay(100);
WiFi.mode(WIFI_AP);
WiFi.softAP(AP_SSID, AP_PASS);
ap_mode = true;
if (!web_started) start_web_if_needed();
}
}

// ===== SHT31 poller =====
static uint32_t last_sht_ms = 0;
static const uint32_t SHT_PERIOD_MS = 30000;  // 30s

static bool sht_ok = false;

static void poll_sht31() {
if (!sht_ok) return;

float t = sht31.readTemperature();
float h = sht31.readHumidity();

if (!isnan(t)) {
last_house_temp = roundf(t * 10) / 10.0f;
ts_house = millis();
if (mqtt.connected()) {
mqtt.publish(T_HOUSE_TEMP, String(last_house_temp, 1).c_str(), true);
}
}
if (!isnan(h)) {
last_house_hum = roundf(h * 10) / 10.0f;
if (mqtt.connected()) {
mqtt.publish(T_HOUSE_HUM, String(last_house_hum, 1).c_str(), true);
}
}
}

// ===== Time / housekeeping =====
static void setup_time() {
  // TZ must be set before configTime to get localtime right
  setenv("TZ", TZSTR, 1);
  tzset();
  configTime(0, 0, NTP1, NTP2, NTP3);
}

static void tick_filter_life() {
  time_t now = time(nullptr);
  if (now <= 0) return;

  long today = (long)(now / 86400);
  if (filter_last_epoch_day < 0) {
    filter_last_epoch_day = today;
    save_main();
    return;
  }
  if (today > filter_last_epoch_day) {
    int dec = (int)(today - filter_last_epoch_day);
    filter_last_epoch_day = today;
    hrv_days_remaining = max(0, hrv_days_remaining - dec);

    int pct = (int)lround(hrv_days_remaining * 100.0 / 730.0);
    if (mqtt.connected()) {
      mqtt.publish(T_FILTER_DAYS, String(hrv_days_remaining).c_str(), true);
      mqtt.publish(T_FILTER_LIFE, String(pct).c_str(), true);
      mqtt.publish(T_FILTER_NEEDED, (pct <= 0) ? "ON" : "OFF", true);
    }
    save_main();
  }
}

static uint32_t last_boost_pub_ms = 0;
static void tick_boost_remaining() {
  if (!boost_active || !mqtt.connected()) return;
  uint32_t now = millis();
  if (now - last_boost_pub_ms >= 1000) {
    last_boost_pub_ms = now;
    int br = boost_remaining_s();
    mqtt.publish(T_BOOST_REMAIN_S, String(br).c_str(), true);
    if (br <= 0) stop_burnt_toast();
  }
}

// ===== Setup & Loop =====
void setup() {
  Serial.begin(115200);
  delay(50);
  Serial.println();
  Serial.println(F("HRV Keypad (ESP8266) booting…"));

  // FS + settings
  if (!LittleFS.begin()) {
    Serial.println(F("LittleFS mount failed"));
  }
  load_settings();

  // Unique MQTT client id
  MQTT_CLIENTID = "hrv-keypad-" + String(ESP.getChipId(), HEX);

  // I2C + SHT31
  Wire.begin(PIN_I2C_SDA, PIN_I2C_SCL);
  sht_ok = sht31.begin(0x44);
  if (!sht_ok) Serial.println(F("SHT31 not found"));

  // HRV bus @1200
  HRV.begin(1200);
  delay(100);
  boot_handshake();

  // Networking
  WiFi.persistent(false);
  WiFi.mode(WIFI_STA);
  wifi_begin_ms = 0;   // let wifi_loop_task kick off connect
  setup_time();

  // Web server can start as soon as we need it (STA or AP)
  start_web_if_needed();

  // First publish of days/life if MQTT comes up quickly
  tick_filter_life();

  Serial.println(F("Setup complete."));
}

void loop() {
  // Connectivity / services
  wifi_loop_task();
  mqtt_loop_task();
  web.handleClient();

  // HRV serial
  process_uart();

  // SHT31 periodic read
  uint32_t now = millis();
  if (now - last_sht_ms >= SHT_PERIOD_MS) {
    last_sht_ms = now;
    poll_sht31();
  }

  // Auto control cadence (lightweight, can run each loop)
  auto_control_task();

  // Housekeeping
  tick_filter_life();
  tick_boost_remaining();

  // Be nice to the CPU
  delay(2);
}
